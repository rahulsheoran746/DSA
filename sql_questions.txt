1.	Given a table that includes user_id, session_id, start_time, and end_time, write a query to find each user's average and maximum time spent.

select user_id, 
max(datediff('second', start_time ,end_time)) as max_time_diff
avg(datediff('second', start_time ,end_time)) as avg_time_diff
from table group by user_id

2.	Given the table Employees (columns: EmployeeID, Name, Department, Salary), write a query to rank employees within each department by their salary in descending order.

select employee_id, name, department, salary, 
rank() over(partition by department order by salary desc) as rnk
from employees

3.	Given the table StockPrices (columns: StockID, PriceDate, Price), calculate the 3-day moving average of stock prices.

select stockid, pricedate, price,
avg(price) over(partition by stockid 
		order by pricedate 
		rows between 2 preceding and current row
		) as avg_price
from stockprices


4.	You have two tables: 
o	employees(emp_id, emp_name, department_id, salary, hire_date)
o	departments(department_id, department_name) 
Write a query to calculate the difference between each employee’s salary and the highest salary within their department. Then, label employees who have a salary within 1000 of the department's highest salary as 'Near Top Earner'.


select emp_id, emp_name, dept_id, salary, hire_date,
(max(salary) over(partition by department_id) - salary)as salary_diff,
case 
when (max(salary) over(partition by department_id) - salary) <=1000  then 'near_top_earner',
else null
end as label
from employees

with salary_info as (
select emp_id, emp_name, dept_id, salary,
max(salary) over(partition by dept_id) as max_salary
from employees
)

select *, 
(max_salary - salary) as salary_diff,
case
when (max_salary - salary) <=1000 then 'near_top_earner'
else null
end as label
from salary info 


5.	Given the userProfile table with fields: 
o	userId
o	ctc
o	total_exper
And the communicationSend table with fields: 
o	userId
o	date
o	communicationType
Write a SQL query to find the distribution of users who have an entry in the communicationSend table with "notification" communication type in the last 30 days. Group users into buckets: 
o	Send count bucket: 0-5, 5-10, 10-15, >15
o	CTC bucket: 0-5, 5-10, 10-15, >15
o	Experience bucket: 0-5, 5-10, 10-15, >15


with user_send_count as (
select u.user_id,
u.ctc,
u.toal_exper
count(u.userid) as send_count
from userprofile u 
left join 
communicationsend c 
on u.userid = c.userid
where communicationType = 'notification' and datediff('day', c.date, currentdate)<=30
group by u.user_id, u.ctc, u.total_exper
),
buckets as (
select user_id,

CASE 
      WHEN send_count BETWEEN 0 AND 4 THEN '0-5'
      WHEN send_count BETWEEN 5 AND 9 THEN '5-10'
      WHEN send_count BETWEEN 10 AND 14 THEN '10-15'
      ELSE '>15'
    END AS send_count_bucket,

    -- CTC bucket
    CASE 
      WHEN ctc BETWEEN 0 AND 4 THEN '0-5'
      WHEN ctc BETWEEN 5 AND 9 THEN '5-10'
      WHEN ctc BETWEEN 10 AND 14 THEN '10-15'
      ELSE '>15'
    END AS ctc_bucket,

    -- Experience bucket
    CASE 
      WHEN total_exper BETWEEN 0 AND 4 THEN '0-5'
      WHEN total_exper BETWEEN 5 AND 9 THEN '5-10'
      WHEN total_exper BETWEEN 10 AND 14 THEN '10-15'
      ELSE '>15'
    END AS experience_bucket
from user_send_count
)

select send_count_bucket, 
ctc_bucket,
experience_bucket,
 count(*) as user_count
 from buckets 
group by   send_count_bucket,
  ctc_bucket,
  experience_bucket
order by 
send_count_bucket,
  ctc_bucket,
  experience_bucket;


I have a table sales_id, product_name, sales_date. We have to give only those rows with latest data based on sales_date.

with ranked_sales as (
select sales_id, product_name ,sales_date,
row_number() over(partition by product_name order by sales_date) as rn
from sales)

select * from ranked_sales where rn =1


A company maintains information about its order on orders table. Write a query to print details of the earliest five orders(sorted by order_date ascending) that have not been delivered(i.e status is not delivered). If there are more than 5 orders to chose from select the ones with the lowest order id. Sort the output in the increasing order of the order_id. the output should contains id, order_date, status, customer_id.

select order_id, order_date,status, customer_id from (
select order_id, order_date,status, customer_id from orders where status !='delivered' order by order_date, order_id limit 5) as sub order by order_id.



Q1. Given a table users in which we have columns as user_id, deptartment, salary and we have to find the diff between 2nd and 3rd highest salary of each dept.



with ranked_salaries as (
	select 
	department, salary,
	dense_rank() over(partition by department order by salar desc) as rnk
	from users
),
filtered as (
	select department, salary,rnk
	from ranked_salaries where rnk in (2, 3)
)

select department,
max(case when rnk = 2 then salary end) as second_highest,
max(case when rnk = 3 then salary end) as third_highest,
max(case when rnk = 2 then salary end)  -  max(case when rnk = 3 then salary end ) as salary_diff
from filtered
group by department
having count(distinct rnk) = 2; 


Q2 You are given a table user_sales with the following columns:

user_id (unique identifier for each user),

quarter (values: 'Q1', 'Q2', 'Q3', 'Q4'),

sales (sales amount for that user in the respective quarter).

Write a SQL query to pivot this data such that each row represents a user and their sales in each quarter, with the output columns:

user_id, Q1_sales, Q2_sales, Q3_sales, Q4_sales.


select user_id,
max(case when quarter = 'Q1' then sales end) as Q1_sales,
max(case when quarter = 'Q2' then sales end) as Q2_sales,
max(case when quarter = 'Q3' then sales end) as Q3_sales,
max(case when quarter = 'Q4' then sales end) as Q4_sales
from sales group by user_id;


You are given three tables:

users(user_id, user_name, manager_id) — contains information about employees and their respective managers.

managers(manager_id, manager_name) — contains information about managers.

orders(order_id, user_id, order_date) — contains information about orders placed by users.

Task:
Write a SQL query to find the names of employees (user_name) and their corresponding manager_name for all employees who have not placed any orders.

select 
u.user_name,
m.manager_name
from users u
left join 
order o on o.user_id = u.user_id
left join managers m on m.manager_id = u.manager_id
where o.user_id is null;


You are given two tables:

employee(emp_id, emp_name, emp_salary, dep_name) 
department(dept_id, dept_name)
Find the emp_name and the corresponding dept_id of employees whose emp_salary is greater than the average salary of their department.

with avg_salary_dept as(
select dep_name, avg(emp_salary) as avg_salary from employee group by dep_name
)

select e.emp_name, d.dept_id
from  employee e 
join 
avg_salary_dept a on e.dept_name = a.dep_name
join 
department d on d.dept_name = e.dept_name
where e.emp_salary > a.avg_salary;



You are given a DataFrame with the following columns:
user_id (integer): Unique identifier for each student
name (string): Name of the student
marks (array of integers): A list containing the marks obtained by the student in 5 different subjects

You are required to calculate the average of the top 3 marks for each student.

from pyspark.sql import SparkSession
from pyspark.sql.functions import explode, col, row_number, avg, round
from pyspark.sql.window import Window


spark = SparkSession.builder\
        .appName('Top 3 average marks ')\
        .getOrCreate()

print('Spark session started successfully.')
spark.sparkContext.setLogLevel('FATAL')

student_date = [(1, 'Janit', [80,70,81,54,90]),
                (2, 'Ankit', [81,72,81,54,91]),
                (3, 'Syed', [82,74,81,56,92]),
                (4, 'Lokesh', [83,76,81,58,93]),
                (5, 'Nishant', [84,70,81,60,94])]

df = spark.createDataFrame(student_date, ['user_id','user_name','marks'])
df.printSchema()

# df.show(truncate = False)

exploded_df = df.withColumn('exploded_marks', explode(col('marks'))).drop(col('marks'))
# exploded_df.show(truncate = False)

window_spec = Window.partitionBy(col('user_id')).orderBy(col('exploded_marks').desc())

r_df = exploded_df.withColumn('row_no', row_number().over(window_spec)).filter(col('row_no').isin([1,2,3]))

# r_df.show(truncate = False)

final_df = r_df.groupby('user_id','user_name').agg(
    round(avg(col('exploded_marks')), 2).alias('avg_marks'))
final_df.show(truncate = False)

"Given a table named users with the following columns: user_id, product_id, and sales, write an SQL query to fetch the top two sales (highest sales amounts) for each user."

select user_id, product_id , sales, 
row_number() over(partition by user_id order by sales desc) as rnk
from sales qualify rnk <=2

SELECT user_id, product_id, sales
FROM (
    SELECT user_id, product_id, sales,
           ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY sales DESC) AS rnk
    FROM sales
) AS ranked
WHERE rnk <= 2;


"data engineer" + "hiring"
